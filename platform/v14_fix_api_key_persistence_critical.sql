BEGIN;

-- FIX: Critical API Key Persistence V14
-- Ensures Table Exists, RPCs are correct, and Permissions are granted to ANON/SERVICE_ROLE.

-- 1. Ensure Table Exists
CREATE TABLE IF NOT EXISTS public.ai_provider_settings (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    provider_name text NOT NULL UNIQUE DEFAULT 'openrouter',
    api_key_encrypted text NOT NULL,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. Enable PGCrypto
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 3. Secure RPC: Save Global Key
-- Security: SECURITY DEFINER allows this to run as superuser/creator, bypassing RLS if needed.
CREATE OR REPLACE FUNCTION public.save_provider_key(
    p_key text
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_secret text := 'deedox_secure_ai_persistence_key_2026';
BEGIN
    INSERT INTO public.ai_provider_settings (provider_name, api_key_encrypted)
    VALUES ('openrouter', pgp_sym_encrypt(p_key, v_secret))
    ON CONFLICT (provider_name)
    DO UPDATE SET 
        api_key_encrypted = pgp_sym_encrypt(p_key, v_secret),
        updated_at = now();
END;
$$;

-- 4. Secure RPC: Get Decrypted Key (Internal Use Only - Service Role)
CREATE OR REPLACE FUNCTION public.get_decrypted_provider_key()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_key text;
    v_secret text := 'deedox_secure_ai_persistence_key_2026';
BEGIN
    SELECT pgp_sym_decrypt(api_key_encrypted::bytea, v_secret) 
    INTO v_key
    FROM public.ai_provider_settings
    WHERE provider_name = 'openrouter';
    
    RETURN v_key;
END;
$$;

-- 5. RPC: Get Masked Key (For Admin UI)
CREATE OR REPLACE FUNCTION public.get_provider_key_masked()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_key text;
    v_secret text := 'deedox_secure_ai_persistence_key_2026';
    v_decrypted text;
BEGIN
    -- Check if exists
    SELECT pgp_sym_decrypt(api_key_encrypted::bytea, v_secret) 
    INTO v_decrypted
    FROM public.ai_provider_settings
    WHERE provider_name = 'openrouter' AND is_active = true;
    
    IF v_decrypted IS NOT NULL AND length(v_decrypted) > 8 THEN
        -- Return masked: "sk-or-xxxx...xxxx"
        RETURN substr(v_decrypted, 1, 10) || '................' || substr(v_decrypted, length(v_decrypted) - 4, 5);
    ELSIF v_decrypted IS NOT NULL THEN
        RETURN '********';
    ELSE
        RETURN NULL;
    END IF;
END;
$$;

-- 6. Grant Permissions (Crucial for Anon Access)
GRANT EXECUTE ON FUNCTION public.save_provider_key(text) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.get_provider_key_masked() TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.get_decrypted_provider_key() TO service_role; -- Only Service Role should decrypt fully

-- 7. RLS
ALTER TABLE public.ai_provider_settings ENABLE ROW LEVEL SECURITY;

-- Allow Service Role full access
DROP POLICY IF EXISTS "Service Role Full Access" ON public.ai_provider_settings;
CREATE POLICY "Service Role Full Access" ON public.ai_provider_settings FOR ALL TO service_role USING (true);

COMMIT;
